<link rel="stylesheet" href="../style.css">

# Software Engineering

<details>
<summary>1. 소프트웨어 아키텍처</summary>

<br/>

> **개념** : (소프트웨어 구성하는 요소 간 관계를 표현하는) 시스템 구조/구조체
>
> - 애플리케이션 분할 방법 / 분할된 모듈에 할당될 기능 / 모듈 간 인터페이스 등 결정

<br/>

> 💡 **소프트웨어 아키텍처 설계 - 기본원리**
> - 모듈화
> - 추상화
> - 단계적 분해
> - 정보 은닉

<br/>

### 1) 모듈화(Modularity)

> **개념** : 시스템 기능을 모듈 단위로 나누는 것
>
> **목적** : 소프트웨어 성능 향상 / 시스템 수정 및 재사용 / 유지 관리 용이
>
> - 모듈 크기 너무 작게 나누면 => 모듈 간 통합 비용 up
> - 모듈 크기 너무 크게 나누면 => 모듈 하나의 개발 비용 up

<br/>

### 2) 추상화(Abstraction)

> **개념** : 전체적/포괄적 개념 설계 후 => 차례로 세분화/구체화
>
> => 시스템 구축 전, 유사 모델 만들어 여러 요인 테스트 가능
>
> **추상화 유형**
> - **과정 추상화** : 자세한 수행 과정 정의 X / 전반 흐름만 파악되게 설계
> - **데이터 추상화** : 데이터 세부 속성, 용도 정의 X / 데이터 구조 대표할 수 있는 표현으로 대체
> - **제어 추상화** : 이벤트 발생의 정확한 절차, 방법 정의 X / 대표할 수 있는 표현으로 대체

<br/>

### 3) 단계적 분해(Stepwise Refinement)

> **개념** : 상위 중요 개념 => 하위 개념으로 구체화시키는 분할 기법 (하향식 설계 전략)
>
> - 포괄적 기능에서 시작 => 구체화
> - 상세 내역은 가능한 뒤로 미루어 진행 (알고리즘, 자료구조 등)

<br/>

### 4) 정보 은닉(Information hiding)

> **개념** : 모듈 내부 절차/자료 감추어져 다른 모듈이 접근/변경 못하도록 하는 기법
>
> - 모듈을 독립적으로 수행 가능
> - 다른 모듈에 영향 X => 수정/시험/유지보수 용이

<br/>

### 5) 소프트웨어 개발의 설계 단계

> - 상위 설계
>    - 아키텍처 설계, 예비 설계
>    - 설계 대상 = 시스템 전체적인 구조
>    - 세부 목록 = 구조, DB, 인터페이스
>
> - 하위 설계
>    - 모듈 설계, 상세 설계
>    - 설계 대상 = 시스템 내부 구조 및 행위
>    - 세부 목록 = 컴포넌트, 자료구조, 알고리즘

<br/>

### 6) 소프트웨어 아키텍처의 품질 속성

> **개념** : **품질 평가 요소** 구체화해 놓은 것
>
> **목적** : 소프트웨어 아키텍처가 이해 관계자들이 **요구하는 품질 수준을 유지/보장**하게 설계되었나 확인

> **품질 평가 요소의 종류**
> - **시스템 측면** : 성능, 보안, 기능성 / 가용성, 사용성 / <u>변경 용이성</u>, 확장성 등
> - **비즈니스 측면** : 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정 등
> - **아키텍처 측면** : 개념적 무결성, 정확성, 완결성 / 구축 가능성, <u>변경성</u>, 시험성 등

<br/>

### 7) 소프트웨어 아키텍처 설계 과정

> - **시스템 설계 목표 설정** : 요구사항 분석해서
>
> - **시스템 타입 결정** : 시스템과 서브시스템 타입 결정, 아키텍처 패턴 선택
>
> - **아키텍처 패턴 적용** : 시스템의 표준 아키텍처 설계
>
> - **서브시스템 구체화** : 서브시스템 기능 및 서브시스템 간 상호작용을 위한 동작/인터페이스 정의
>
> - **검토** : 아키텍처 검토 (설계 목표, 요구사항, 설계 기본 원리 등 만족하는지)

<br/>

### 8) 협약(Contract)에 의한 설계

> **개념** : 컴포넌트 설계 시, 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것
>
> => 컴포넌트에 대한 정확한 인터페이스를 명세
>
> **명세에 포함될 조건**
> - 선행 조건(Precondition) : 오퍼레이션 호출 전, 참이 되어야 할 조건
> - 결과 조건(Postcondition) : 오퍼레이션 수행 후, 만족되어야 할 조건
> - 불변 조건(Invariant) : 오퍼레이션 실행되는 동안, 항상 만족되어야 할 조건

<br/>

</details>



<details>
<summary>2. 아키텍처 패턴(Patterns)</summary>

<br/>

> **개념** : 아키텍처 설계 시, 참조할 수 있는 전형적 해결 방식/예제
>
> **특징**
> - 소프트웨어 시스템의 구조 구성을 위한 기본 윤곽 제시
> - 서브시스템들과 그 역할 정의
> - 서브시스템 사이 관계, 여러 규칙/지침 등 포함
>
> **주요 아키텍처 패턴 종류**
> - 레이어 패턴
> - 클라이언트-서버 패턴
> - 파이프-필터 패턴
> - 모델-뷰-컨트롤러 패턴

<br/>

### 1) 레이어 패턴(Layers Pattern)

> **개념** : 시스템을 계층으로 구분하여 구성
>
> => 마주보는 두 개 계층 사이에서만 상호작용 (ex. OSI 참조 모델)
>
> - 상위 계층 = 하위 계층의 클라이언트
> - 하위 계층 = 상위 계층에 대한 서비스 제공자

<br/>

### 2) 클라이언트-서버 패턴(Client-Server Pattern)

> **개념** : 하나의 서버 컴포넌트 & 다수의 클라이언트 컴포넌트로 구성
>
> => 사용자가 클라이언트 통해 서버에 요청 / 클라이언트가 응답 받아 사용자에게 제공

<br/>

### 3) 파이프-필터 패턴(Pipe-Filter Pattern)

> **개념** : 데이터 스트림 절차의 단계를 필터로 캡슐화 => 파이프를 통해 전송
>
> - 앞 시스템의 결과 => 파이프로 전달받아 처리 후 => 다음 시스템으로
> - 데이터 변환, 버퍼링, 동기화 등에 주로 사용
> - ex) UNIX의 쉘(Shell)

<br/>

### 4) 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)

> **개념** : 서브시스템을 모델/뷰/컨트롤러로 구조화
>
> - 컨트롤러가 사용자 요청 받으면 / (핵심 기능과 데이터를 보관하는) 모델 이용 => 뷰에 정보 출력
> - 여러 개의 뷰 만들 수 O
> - (한 개 모델에 대해 여러 개 뷰를 필요로 하는) '대화형 애플리케이션'에 적합

<br/>

### 5) 기타 패턴

> - **마스터-슬레이브 패턴(Master-Slave Pattern)**
>    - 슬레이브 컴포넌트에서 처리된 결과 => 다시 돌려받는 방식
>    - ex) 장애 허용 시스템, 병렬 컴퓨팅 시스템
>
> - **브로커 패턴(Broker Pattern)**
>    - 사용자가 원하는 서비스/특성을 브로커 컴포넌트에 요청
>    - 브로커 컴포넌트가 적합한 컴포넌트와 사용자 연결
>    - ex) 분산 환경 시스템
>
> - **피어-투-피어 패턴(Peer-To-Peer Pattern)**
>    - 피어(Peer)라 불리는 컴포넌트가 클라이언트가 될 수도 / 서버가 될 수도
>    - ex) 파일 공유 네트워크
>
> - **이벤트-버스 패턴(Event-Bus Pattern)**
>    - 소스가 특정 채널에 이벤트 메시지 발행(Publish)
>    - 해당 채널 구독(Subscribe)한 리스너(Listener)들이 메시지 받아 처리
>    - ex) 알림 서비스
>
> - **블랙보드 패턴(Blackboard Pattern)**
>    - 모든 컴포넌트가 공유 데이터 저장소 & 블랙보드 컴포넌트에 접근 가능
>    - ex) 음성 인식, 차량 식별, 신호 해석
>
> - **인터프리터 패턴(Interpreter Pattern)**
>    - 프로그램 코드 각 라인 수행 방법 지정 / 기호마다 클래스 갖도록 구성
>    - ex) 번역기, 컴파일러, 인터프리터

<br/>

</details>



<details>
<summary>3. 객체 지향(Object-Oriented)</summary>

<br/>

> **개념** : 소프트웨어 각 요소를 객체(Object)로 만든 후 => 객체 조립해서 소프트웨어 개발
>
> - (구조적 기법의 문제로 인한) 소프트웨어 위기의 해결책
> - 재사용 및 확장 용이 => 고품질 소프트웨어 빠르게 개발 가능 & 유지보수 쉬움
>
> **객체 지향 - 구성 요소**
> - 객체 (Object)
> - 클래스 (Class)
> - 메시지 (Message)
>
> **객체 지향 - 특징**
> - 캡슐화 (Encapsulation)
> - 상속 (Inheritance)
> - 다형성 (Polymorphism)
> - 연관성 (Relationship)

> ✅ **객체 지향 - 특징 (추가적)**
>
> - 추상화 (Abstraction)
> - 정보 은닉 (Information Hiding)

<br/>

### 1) 객체 (Object)

> **개념** : 데이터 & 함수 묶어놓은 소프트웨어 모듈
>
> - **데이터**
>    - 객체가 가진 정보
>    - = 속성, 상태, 변수, 상수, 자료구조
>
> - **함수**
>    - 객체가 수행하는 기능 / 데이터 처리 알고리즘 / 객체 상태의 참조 및 변경 수단
>    - = 메소드(Method), 서비스(Service), 동작(Operation), 연산

<br/>

### 2) 클래스 (Class)

> **개념** : 공통 속성, 연산을 갖는 객체의 집합
>
> - 데이터 추상화의 단위
> - 각각의 객체가 갖는 속성, 연산을 정의
> - 인스턴스(Instance) = 클래스에 속한 각각의 객체

<br/>

### 3) 메시지 (Message)

> **개념** : 객체 간 상호작용에 사용되는 수단, 객체에게 행위를 지시하는 명령/요구사항
>
> - 메시지 받은 객체는 대응하는 연산 수행 => 예상 결과 반환

<br/>

### 4) 캡슐화 (Encapsulation)

> **개념** : 외부 접근 제한 위해, **인터페이스 제외**한 세부 내용 은닉(정보 은닉)
>
> - 외부 모듈 변경으로 인한 파급 효과 적음
> - 인터페이스 단순, 객체 간 결합도 낮아짐

<br/>

### 5) 상속 (Inheritance)

> **개념** : 상위(부모) 클래스의 모든 속성, 연산 => 하위(자식) 클래스가 물려받는 것
>
> - 하위 클래스는 물려받은 속성, 연산 재정의 안해도 사용 가능
> - 하위 클래스는 새로운 속성, 연산 추가 가능

<br/>

### 6) 다형성 (Polymorphism)

> **개념** : (하나의 메시지에 대해) 각각의 객체가 가진 고유 방법으로 응답 가능한 능력 (여러 형태의 응답)
>
> - 객체들은 동일한 메소드명 사용 / 같은 의미의 응답
> - ex) '+' 연산자 : 숫자 클래스는 덧셈, 문자 클래스는 연결

<br/>

### 7) 연관성 (Relationship)

> **개념** : 두 개 이상의 객체들이 **상호 참조**하는 관계
>
> **종류**
>
> - **is member of**
>    - 연관화(Association) : 2개 이상의 객체가 상호 관련
>
> - **is instance of**
>    - 분류화(Classification) : 동일한 형의 특성을 갖는 객체들 모아 구성
>
> - **is part of**
>    - 집단화(Aggregation) : 관련 있는 객체를 묶어 하나의 상위 객체 구성
> 
> - **is a**
>    - 일반화(Generalization) : 공통 성질로 추상화한 상위 객체 구성
>    - 특수화/상세화(Specialization) : 상위 객체를 구체화하여 하위 객체 구성

<br/>

</details>













