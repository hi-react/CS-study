<link rel="stylesheet" href="../style.css">

# Software Engineering

<details>
<summary>1. 객체지향 분석 및 설계</summary>

<br/>

### 1) 객체지향 분석(OOA; Object Oriented Analysis)

> **개념** : (사용자 요구사항과 관련된) 객체, 속성, 연산, 관계 등 정의해 모델링
>
> **목적** : 클래스 식별
>
> - 객체와 속성 / 클래스와 멤버 / 전체와 부분 등으로 나누어 분석

<br/>

### 2) 객체지향 분석의 방법론

> **Rumbaugh(럼바우) 방법** 
>    - '객체 / 동적 / 기능' 모델로 나누어 분석 활동함
>
> **Booch(부치) 방법**
>    - 미시적 / 거시적 개발 프로세스 모두 사용
>    - 클래스와 객체들을 분석 및 식별 / 클래스 속성과 연산 정의
>
> **Jacobson 방법**
>    - 유스케이스(Use Case) 강조하여 사용
>
> **Coad와 Yourdon 방법**
>    - E-R 다이어그램 사용 => 객체 행위 모델링
>    - 객체 식별 / 구조 식별 / 주제 정의 / 속성과 인스턴스 연결 정의 / 연산과 메시지 연결 정의 등의 과정
>
> **Wirfs-Brock 방법**
>    - 분석과 설계 구분 X
>    - 고객 명세서 평가 => 설계까지 연속 수행

<br/>

### 3) 럼바우(Rumbaugh)의 분석 기법

> **개념** : 모든 소프트웨어 구성 요소를 '그래픽 표기법' 이용해 모델링
>
> (= 객체 모델링 기법, OMT, Object-Modeling Technique)

<br/>

> **분석 활동** : 객체 모델링 => 동적 모델링 => 기능 모델링 순
>
>    - **객체 모델링(Object Modeling)**
>        - = 정보 모델링, Information Modeling
>        - 요구되는 객체 찾아, 속성과 연산 식별 & 객체 간 관계 규정 => 객체 다이어그램으로 표시
>
>    - **동적 모델링(Dynamic Modeling)**
>        - 상태 다이어그램 이용
>        - (시간 흐름에 따른) 객체 간 제어 흐름, 상호 작용, 동작 순서 등 동적 행위 표현
>
>    - **기능 모델링(Functional Modeling)**
>        - 자료 흐름(DFD) 이용
>        - 다수 프로세스 간 자료 흐름을 중심으로 처리 과정 표현

<br/>

### 4) 객체지향 설계 원칙 SOLID

> **개념** : 변경/확장에 유연한 시스템 설계를 위해 지켜야 할 원칙
>
> - **단일 책임 원칙(SRP)** : 객체는 단 하나의 책임만
>
> - **개방-폐쇄 원칙(OCP)** : 기존 코드 변경 없이, 기능 추가할 수 있도록
>
> - **리스코프 치환 원칙(LSP)** : 자식 클래스 = 최소한 부모 클래스 기능은 수행
>
> - **인터페이스 분리 원칙(ISP)** : 사용하지 않는 인터페이스와 의존 관계 or 영향 X
>
> - **의존 역전 원칙(DIP)** : 추상성 높은 클래스와 의존 관계 맺어야 함

<br/>

</details>



<details>
<summary>2. 모듈 (Module)</summary>

<br/>

> **개념** : 모듈화 통해 분리된 시스템의 각 기능 (서브루틴, 서브시스템, 소프트웨어 내 프로그램, 작업 단위 등)
>
> - **모듈의 기능적 독립성** 높이려면?
>    - 결합도 (Coupling) 낮추고
>    - 응집도 (Cohesion) 높이고
>    - 모듈 크기 작게

<br/>

### 1) 결합도 (Coupling)

> **개념** : 모듈 간 상호 의존도 (연관 관계)
>
> - 결합도 약할수록 => 품질이 높다.

<br/>

> **종류** (결합도 강한 순서대로 - 내공외제스자)
>
> - **내용 결합도(Content Coupling)**
>    - 한 모듈이 다른 모듈 내부 기능/자료 직접 참조/수정 시
>
> - **공통(공유) 결합도(Common Coupling)**
>    - 공유 데이터 영역을 여러 모듈이 사용 시
>    - 전역 변수 사용해, 전역 변수 갱신하는 방식으로 상호 작용 시
>
> - **외부 결합도(External Coupling)**
>    - 어떤 모듈에서 선언한 데이터(변수)를 외부 다른 모듈에서 참조 시
>
> - **제어 결합도(Control Coupling)**
>    - 어떤 모듈이 다른 모듈 내부의 논리 흐름 제어 위해, 제어 신호/요소 전달 시
>    - 하위에서 상위 모듈로 제어 신호 이동 => (하위가 상위에 처리 명령 내리는) 권리 전도 현상 발생
>
> - **스탬프(검인) 결합도(Stamp Coupling)**
>    - 모듈 간 인터페이스로 배열/레코드 등 자료 구조가 전달될 때
>
> - **자료 결합도(Data Coupling)**
>    - 모듈 간 인터페이스가 자료 요소로만 구성될 때

<br/>

### 2) 응집도 (Cohesion)

> **개념** : 모듈 내부 요소 간 관련 정도
>
> - 응집도 강할수록 => 품질이 높다.

<br/>

> **종류** (응집도 강한 순서대로)
>
> - **기능적 응집도(Functional Cohesion)**
>    - 모듈 내부 모든 기능 요소 => 단일 문제와 연관되어 수행될 때
>
> - **순차적 응집도(Sequential Cohesion)**
>    - 모듈 내 하나의 활동으로부터 나온 출력 데이터 => 다음 활동 입력 데이터로 사용 시
>
> - **교환(통신)적 응집도(Communication Cohesion)**
>    - 동일 입/출력 사용해, 서로 다른 기능 수행하는 구성 요소들 모여있을 때
>
> - **절차적 응집도(Procedural Cohesion)**
>    - 모듈이 다수의 관련 기능 가질 때, 모듈 내 구성 요소들이 그 기능을 순차적으로 수행할 경우
>
> - **시간적 응집도(Temporal Cohesion)**
>    - 특정 시간에 처리되는 몇 개 기능을 하나의 모듈로 작성할 경우
>
> - **논리적 응집도(Logical Cohesion)**
>    - 유사 성격, 특정 형태로 분류되는 처리 요소들로 하나의 모듈 형성할 경우
>
> - **우연적 응집도(Coincidental Cohesion)**
>    - 모듈 내 구성 요소들이 관련 없는 요소들로만 구성된 경우

<br/>

### 3) 팬인(Fan-In) / 팬아웃(Fan-Out)

> 💡 팬인/팬아웃 분석 => 시스템 복잡도 알 수 있다.
>
> **시스템 복잡도 최적화** 하려면? : 팬인 높게, 팬아웃 낮게
>
> - **팬인** : 어떤 모듈을 제어하는 모듈 수
>
> - **팬아웃** : 어떤 모듈에 의해 제어되는 모듈 수

<br/>

> ✅ **팬인이 높다**
>
> - (재사용 측면에서) 설계 good
> - 단일 장애점 발생 가능 => 중점적인 관리 & 테스트 필요

<br/>

### 4) N-S 차트 (Nassi-Schneiderman Chart)

> **개념** : 논리 기술에 중점, 도형 이용해 표현하는 방법 (= 박스 다이어그램, Chapin Chart)
>
> - GOTO나 화살표 사용 X
> - 연속 / 선택 및 다중 선택 / 반복 -----> 3가지 제어 논리 구조로 표현
> - 조건이 복합된 처리를 시각적으로 명확히 식별하는 데 적합

<br/>

</details>



<details>
<summary>3. 단위 모듈 (Unit Module)</summary>

<br/>

> **개념** : (소프트웨어 구현에 필요한) 한 가지 동작을 수행하는 기능을 모듈로 구현한 것
>
> - **단위 기능** : 단위 모듈로 구현되는 하나의 기능
>
> - 독립적 컴파일 가능 / 다른 모듈에 호출, 삽입 가능

<br/>

> 📌 **단위 모듈 구현 과정**
>
> - 단위 기능 명세서 작성
>    - 기능, 코드 명세서, 설계 지침 등
>
> - 입/출력 기능 구현
>    - (입/출력 기능을 위한) 알고리즘 및 데이터 구현
>
> - 알고리즘 구현
>    - 단위 기능별 모듈 구현

<br/>

### 1) IPC (Inter-Process Communication)

> **개념** : (모듈 간 통신 방식 구현을 위해 사용되는) 대표적 프로그래밍 인터페이스 집합

<br/>

> 💡 **IPC 대표 메소드 (5가지)**
>
> - **Shared Memory** : 공유 가능한 메모리를 구성해, 다수의 프로세스가 통신
>
> - **Socket** : 네트워크 소켓 이용해, 네트워크를 경유하는 프로세스 간 통신
>
> - **Semaphores** : 공유 자원에 대한 접근 제어를 통해 통신
>
> - **Pipes & named Pipes** : Pipe라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신
>
> - **Message Queueing** : 메시지가 발생하면, 이를 전달하는 방식으로 통신

<br/>

### 2) 단위 모듈 테스트

> **개념** : (단위 기능으로 구현된) 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것 (= 단위 테스트, Unit Test)
>
> - 단위 모듈 테스트의 기준 = (단위 모듈에 대한) 코드
> - 따라서, 시스템 수준 오류는 잡을 수 X

<br/>

### 3) 테스트 케이스 (Test Case)

> **개념** : 소프트웨어가 사용자 요구사항을 정확히 준수했는지 확인하기 위한 테스트 항목 명세서
>
> 테스트 케이스 이용하지 않으면?
>    - 특정 요소에 대한 검증 누락 or 불필요한 검증 반복으로 인력/시간 낭비

<br/>

> 💡 (ISO/IEC/IEEE 29119-3 표준에 따른) **테스트 케이스 구성 요소**
>
> - **식별자(Identifier)** : 항목 식별자, 일련번호
>
> - **테스트 항목(Test Item)** : 테스트 대상(모듈 or 기능)
>
> - **입력 명세(Input Specification)** : 입력 데이터 or 테스트 조건
>
> - **출력 명세(Output Specification)** : 테스트 케이스 수행 시 예상되는 출력 결과
>
> - **환경 설정(Environmental Needs)** : 필요한 하드웨어나 소프트웨어 환경
>
> - **특수 절차 요구(Special Procedure Requirement)** : 테스트 케이스 수행 시 특별히 요구되는 절차
>
> - **의존성 기술(Inter-case Dependencies)** : 테스트 케이스 간의 의존성

<br/>

</details>



<details>
<summary>4. 공통 모듈</summary>

<br/>

> **개념** : 여러 프로그램에서 공통으로 사용할 수 있는 모듈 (ex. 자주 사용되는 계산식, 사용자 인증)
>
> => 공통 모듈 구현 시, (해당 기능 명확히 이해할 수 있도록) **명세 기법** 준수해야 함

<br/>

### 1) 공통 모듈 명세 기법 - 종류

> - **정확성(Correctness)** : 시스템 구현 시, (해당 기능이 필요한 걸 알 수 있도록) 정확히 작성
>
> - **명확성(Clarity)** : 중의적으로 해석되지 않도록 명확히 작성
>
> - **완전성(Completeness)** : 시스템 구현을 위해 필요한 모든 것 기술
>
> - **일관성(Consistency)** : 공통 기능들 간 상호 충돌 발생하지 않게 작성
>
> - **추적성(Traceability)** : 기능에 대한 요구사항의 출처, 관련 시스템 등 관계 파악할 수 있게 작성

<br/>

### 2) 재사용(Reuse)

> **개념** : 이미 개발된 기능을 새로운 시스템/기능 개발에 사용하기 적합하도록 최적화하는 것
>
> - 새로 개발하는 데 필요한 비용/시간 절약 가능
> - 누구나 이해할 수 있고, 사용 가능하도록 사용법 공개해야 함

<br/>

> 💡 **재사용 규모에 따른 분류**
>
> - **함수와 객체** : 클래스나 메소드 단위의 소스 코드 재사용
>
> - **컴포넌트**
>    - 독립적인 업무/기능 수행하는 실행 코드 기반으로 작성된 모듈
>    - (컴포넌트 자체에 대한 수정 없이) 인터페이스 통해 통신하는 방식으로 재사용
>
> - **애플리케이션** : 공통 기능을 제공하는 애플리케이션을 공유하는 방식으로 재사용

<br/>

### 3) 효과적인 모듈 설계 방안

> - 결합도(Coupling) 줄이고, 응집도(Cohesion) 높여서 => 모듈 독립성, 재사용성 높인다.
>
> - 복잡도, 중복성 줄이고 / 일관성 유지
>
> - 모듈의 기능 = 예측 가능해야 하고, 지나치게 제한적이면 X
>
> - 모듈 크기 = 시스템 전반의 기능/구조 이해하기 쉬운 크기로 분해
>
> - (효과적인 제어를 위해) 모듈 간 계층적 관계를 정의하는 자료가 제시되어야 한다.

<br/>

</details>



<details>
<summary>5. 코드(Code)</summary>

<br/>

> **개념** : 자료의 **분류 / 조합 / 집계 / 추출**을 용이하게 하기 위해 사용하는 기호
>
> - 정보를 신속 / 정확 / 명료하게 전달 가능
> - 일정한 규칙에 따라 작성
> - 정보 처리 효율 & 처리된 정보의 가치에 많은 영향을 미침

<br/>

### 1) 코드의 주요 기능

> - **식별 기능** : 데이터 간 성격에 따라 구분
> - **분류 기능** : 특정 기준 / 동일 유형에 해당하는 데이터 그룹화
> - **배열 기능** : 의미 부여하여 나열
> - **표준화 기능** : 다양한 데이터를 기준에 맞추어 표현
> - **간소화 기능** : 복잡한 데이터를 간소화

<br/>

### 2) 코드의 종류

> - **순차 코드(Sequence Code)**
>    - 일정 기준(자료 발생 순서, 크기 순서 등)에 따라 차례로 일련 번호 부여
>    - = 순서 코드, 일련번호 코드 (ex. 1, 2, 3, 4, ...)
>
> - **블록 코드(Block Code)**
>    - (코드화 대상 항목 중) 공통적인 것끼리 블록으로 구분 => 각 블록 내에서 일련번호 부여
>    - = 구분 코드 (ex. 1001 ~ 1100 : 총무부 / 1101 ~ 1200 : 영업부)
>
> - **10진 코드(Decimal Code)**
>    - 0 ~ 9까지 10진 분할 => 다시 각각에 대해 10진 분할 (필요한 만큼 반복)
>    - = 도서 분류식 코드 (ex. 1000 : 공학 / 1100 : 소프트웨어 공학 / 1110 : 소프트웨어 설계)
>
> - **그룹 분류 코드(Group Classification Code)** 
>    - 일정 기준에 따라 대분류 / 중분류 / 소분류 등으로 구분 => 각 그룹 내에서 일련번호 부여
>    - ex) 1-01-001 : 본사-총무부-인사계 / 2-01-001 : 지사-총무부-인사계
>
> - **연상 코드(Mnemonic Code)**
>    - (코드화 대상 항목의) 명칭/약호와 관계 있는 숫자/문자/기호 이용해 코드 부여
>    - ex) TV-40 : 40인치 TV / L-15-220 : 15W 220V의 램프
> 
> - **표의 숫자 코드(Significant Digit Code)**
>    - 성질(길이, 넓이, 부피, 지름, 높이 등) 같은 물리적 수치를 그대로 코드에 적용 
>    - = 유효 숫자 코드 (ex. 120-720-1500 : 두께x폭x길이가 120x720x1500 인 강판)
>
> - **합성 코드(Combined Code)**
>    - 2개 이상의 코드를 조합
>    - ex) 연상 코드 + 순차 코드 : KE-711 : 대한항공 711기 / AC-253 : 에어캐나다 253기

<br/>

</details>



<details>
<summary>6. 디자인 패턴 (Design Pattern)</summary>

<br/>

> **개념** : 모듈 간 관계 및 인터페이스 설계 시, 참조할 수 있는 전형적인 해결 방식(예제)
>
> **구성** : 문제 및 배경, 적용 사례, 재사용 가능한 샘플 코드 등
>
> **GOF의 디자인 패턴** : 생성 패턴 / 구조 패턴 / 행위 패턴

<br/>

### 1) 생성 패턴 (Creational Pattern)

> 💡 **개념** : 클래스/객체의 생성/참조 과정을 정의하는 패턴

> - **추상 팩토리(Abstract Factory)**
>    - 구체적인 클래스에 의존 X
>    - 인터페이스를 통해 서로 연관/의존하는 객체 그룹으로 생성 => 추상적으로 표현
>    - 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능
>
> - **빌더(Builder)**
>    - 인스턴스를 조합하여 객체 생성
>    - 객체 생성 과정과 표현 방법 분리 => 동일한 객체 생성에서도 서로 다른 결과 만들 수 O
>
> - **팩토리 메소드(Factory Method)**
>    - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화
>    - 상위 클래스에서 인터페이스만 정의 / 실제 생성은 서브 클래스가 담당
>    - = 가상 생성자(Virtual Constructor) 패턴
>
> - **프로토타입(Prototype)**
>    - 원본 객체를 복제하는 방법으로 객체 생성 / 일반적인 방법으로 객체 생성
>    - 주로, 비용이 큰 경우에 이용
>
> - **싱글톤(Singleton)**
>    - 하나의 객체 생성 => 어디서든 참조 가능, but 여러 프로세스가 동시에 참조 X
>    - 클래스 내에서 인스턴스가 하나뿐임을 보장
>    - 불필요한 메모리 낭비 최소화

<br/>

### 2) 구조 패턴 (Structural Pattern)

> 💡 **개념** : 클래스/객체들을 조합하여 더 큰 구조로 만드는 패턴

> - **어댑터(Adapter)**
>    - 호환성 없는 클래스들의 인터페이스 => 다른 클래스가 이용할 수 있게 변환
>    - 기존 클래스 이용하고 싶은데, 인터페이스 불일치할 때 이용
>
> - **브리지(Bridge)**
>    - 구현부에서 추상층 분리 => 독립적으로 확장할 수 있도록 구성
>    - 기능과 구현을 두 개의 별도 클래스로 구현
>
> - **컴포지트(Composite)**
>    - 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용
>    - 객체를 트리 구조로 구성 => 복합 객체 안에 복합 객체가 포함되는 구조 구현 가능
>
> - **데코레이터(Decorator)**
>    - 객체 간 결합을 통해 능동적으로 기능 확장 가능
>    - 임의 객체에 부가 기능 추가하기 위해 다른 객체 덧붙이는 방식
>
> - **퍼싸드(Facade)**
>    - 상위에 인터페이스 구성 => 서브 클래스들의 기능을 간편하게 사용하도록 함
>    - 서브 클래스 간 통합 인터페이스를 제공하는 Wrapper 객체 필요
>
> - **플라이웨이트(Flyweight)**
>    - 인스턴스를 매번 생성하지 않고, 가능한 한 공유해서 사용 => 메모리 절약
>    - 다수의 유사 객체 생성/조작 시 유용
>
> - **프록시(Proxy)**
>    - 접근 어려운 객체 & 연결하려는 객체 사이에서 인터페이스 역할 수행 (= 대리자)
>    - 내부에서는 객체 간 관계 단순하게 정리 / 외부에서는 객체의 세부 내용 숨김

<br/>

### 3) 행위 패턴 (Behavioral Pattern)

> 💡 **개념** : 클래스/객체들이 상호작용하는 방법 or 책임 분배 방법 정의하는 패턴

> - **책임 연쇄(Chain of Responsibility)**
>    - 요청 처리 가능한 객체가 둘 이상 존재 / 한 객체가 처리 못하면 다음 객체로
>    - 각 객체들이 고리(Chain)로 묶여 있어 => 요청 해결 시까지 책임 전가
>
> - **커맨드(Command)**
>    - 요청을 객체 형태로 캡슐화하여, (재이용/취소할 수 있도록) 요청에 필요한 정보 저장하거나 로그 남김
>    - 요청에 사용되는 명령어 => 추상 클래스 / 구체 클래스로 분리
>
> - **인터프리터(Interpreter)**
>    - 언어에 문법 표현을 정의
>    - SQL이나 통신 프로토콜 개발 시 사용
>
> - **반복자(Iterator)**
>    - 접근이 잦은 객체(ex. 자료구조)에 대해 동일한 인터페이스 사용하도록 함
>    - 내부 표현 방법 노출 없이, 순차적 접근 가능
>
> - **중재자(Mediator)**
>    - 객체 간 복잡한 상호작용(Interface)을 캡슐화 => 객체로 정의
>    - 객체 간 의존성 줄여, 결합도 감소
>
> - **메멘토(Memento)**
>    - 특정 시점에서의 객체 내부 상태 객체화 => 요청에 따라 객체를 해당 시점 상태로 돌릴 수 있음
>    - 주로, Ctrl + Z 같은 되돌리기 기능 개발 시 이용
>
> - **옵서버(Observer)**
>    - 한 객체 상태 변화 => 객체에 상속되어 있는 다른 객체들에게 변화 상태 전달
>    - 일대다의 의존성을 정의
>    - 주로, 분산 시스템 간 이벤트 생성/발행(Publish) & 수신(Subscribe) 해야 할 때 이용
>
> - **상태(State)**
>    - 객체 상태에 따라 동일한 동작 다르게 처리해야 할 때 사용
>    - 객체 상태 캡슐화 => 이를 참조하는 방식
>
> - **전략(Strategy)**
>    - 동일 계열의 알고리즘을 개별적으로 캡슐화 => 상호 교환할 수 있게 정의
>    - 클라이언트는 독립적으로 알고리즘 선택 사용 가능
>    - 클라이언트에 영향 없이 알고리즘 변경 가능
>
> - **템플릿 메소드(Template Method)**
>    - 상위 클래스에서 골격 정의 / 하위 클래스에서 세부 처리 구체화
>    - 유사한 서브 클래스 묶어, 공통 내용을 상위 클래스에서 정의 => 코드 양 줄이고, 유지보수 용이
>
> - **방문자(Visitor)**
>    - 각 클래스들의 데이터 구조에서 처리 기능 분리 => 별도 클래스로 구성
>    - 분리된 처리 기능 = 각 클래스 방문(Visit)하여 수행

<br/>

</details>



<details>
<summary>7. XML (eXtensible Markup Language)</summary>

<br/>

> **개념** : 특수 목적을 갖는 마크업 언어를 만드는 데 사용되는 **다목적 마크업 언어**
>
> => 유니코드 기반으로 (송/수신 시스템 간 전송되는) 데이터가 동일한 구조로 구성될 수 있도록 형태 정의
>
> **목적**
> - 원활한 데이터 연계
> - 웹 브라우저 간 HTML 문법이 호환되지 않는 문제, SGML의 복잡함 해결하기 위해
>
> **특징**
> - 사용자가 문서 태그 정의 가능 / 다른 사용자가 정의한 태그 사용 가능
> - 트리 구조로 구성 => 여러 개의 하위 태그 가질 수 O

<br/>

### 1) SOAP (Simple Object Access Protocol)

> **개념** : 네트워크 상에서 HTTP/HTTPS, SMTP 등 이용해 **XML 교환하기 위한 통신 규약**
>
> **특징**
> - 웹 서비스에서 사용되는 메시지 형식, 처리 방법 지정
> - (기본적으로) HTTP 기반에서 동작 => 프록시, 방화벽 영향 없이 통신 가능
> - 최근, (무거운 구조의) SOAP 대신, RESTful 프로토콜 이용하기도 함

<br/>

> 💡 **RESTful 프로토콜** 
>
> HTTP와 REST 원칙 사용하여 구현되는 웹 서비스 (HTTP로 자원 관리하는 데에 사용되는 웹 서비스 API 집합)

<br/>

### 2) WSDL (Web Services Description Language)

> **개념** : 웹 서비스 관련 서식 or 프로토콜 등을 표준 방법으로 기술하고 게시하기 위한 언어
>
> **특징**
> - XML로 작성됨 / UDDI의 기초
> - SOAP, XML 스키마와 결합 => 인터넷 웹 서비스 제공하기 위해 사용
> - (WSDL 파일 통해) 클라이언트는 서버에서 어떠한 조작 가능한 지 파악 가능

<br/>

</details>


































